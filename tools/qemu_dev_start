#!/usr/bin/env bash
#
#    Copyright (C) 2020 Santiago Piccinini <spiccinini@altermundi.net>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# ARG_OPTIONAL_SINGLE([libremesh-workdir],[],[Optional path to a libremesh working directory to include it as a layer over the rootfs.])
# ARG_OPTIONAL_SINGLE([monitor-port],[],[Qemu monitor port],[45454])
# ARG_OPTIONAL_BOOLEAN([enable-wan],[],[Enable wan (needs dnsmasq installed)],[])
# ARG_OPTIONAL_BOOLEAN([serial],[],[Start the serial terminal],[on])
# ARG_OPTIONAL_BOOLEAN([verbose],[],[Turn on verbose mode],[])
# ARG_POSITIONAL_SINGLE([rootfs],[Path to a x86-64-generic-rootfs.tar.gz],[])
# ARG_POSITIONAL_SINGLE([ramfs],[Path to a x86-64-ramfs.bzImage],[])
# ARG_HELP([Helper to run libremesh in a qemu x86_64 for development purposes])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_libremesh_workdir=
_arg_monitor_port="45454"
_arg_enable_wan="off"
_arg_serial="on"
_arg_verbose="off"


print_help()
{
	printf '%s\n' "Helper to run libremesh in a qemu x86_64 for development purposes"
	printf 'Usage: %s [--libremesh-workdir <arg>] [--monitor-port <arg>] [--(no-)enable-wan] [--(no-)serial] [--(no-)verbose] [-h|--help] <rootfs> <ramfs>\n' "$0"
	printf '\t%s\n' "<rootfs>: Path to a x86-64-generic-rootfs.tar.gz"
	printf '\t%s\n' "<ramfs>: Path to a x86-64-ramfs.bzImage"
	printf '\t%s\n' "--libremesh-workdir: Optional path to a libremesh working directory to include it as a layer over the rootfs. (no default)"
	printf '\t%s\n' "--monitor-port: Qemu monitor port (default: '45454')"
	printf '\t%s\n' "--enable-wan, --no-enable-wan: Enable wan (needs dnsmasq installed) (off by default)"
	printf '\t%s\n' "--serial, --no-serial: Start the serial terminal (on by default)"
	printf '\t%s\n' "--verbose, --no-verbose: Turn on verbose mode (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--libremesh-workdir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_libremesh_workdir="$2"
				shift
				;;
			--libremesh-workdir=*)
				_arg_libremesh_workdir="${_key##--libremesh-workdir=}"
				;;
			--monitor-port)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_monitor_port="$2"
				shift
				;;
			--monitor-port=*)
				_arg_monitor_port="${_key##--monitor-port=}"
				;;
			--no-enable-wan|--enable-wan)
				_arg_enable_wan="on"
				test "${1:0:5}" = "--no-" && _arg_enable_wan="off"
				;;
			--no-serial|--serial)
				_arg_serial="on"
				test "${1:0:5}" = "--no-" && _arg_serial="off"
				;;
			--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'rootfs' and 'ramfs'"
	test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_rootfs _arg_ramfs "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
### START OF CODE GENERATED BY Argbash v2.8.1 one line above, https://argbash.io/generate ###

if [ "$_arg_verbose" == "on" ]; then
    set -x
fi

# LAN ifc. We may use a DHCP client, but we are forcing a fixed ip
ip tuntap add name lime_tap0 mode tap
ip addr add 10.13.0.99/24 dev lime_tap0
ip link set lime_tap0 up

if [ "$_arg_enable_wan" == "on" ]; then
    # WAN ifc
    ip tuntap add name lime_tap1 mode tap
    ip addr add 172.99.0.1/24 dev lime_tap1
    ip link set lime_tap1 up

    # DHCP server for WAN ifc
    dnsmasq -F 172.99.0.100,172.99.0.100 --dhcp-option=3,172.99.0.1 -i lime_tap1 --dhcp-authoritative --log-dhcp

    # enable forwarding and NAT
    echo 1 > /proc/sys/net/ipv4/ip_forward
    iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
    iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -i  lime_tap1  -o wlan0 -j ACCEPT
fi

# Convert the rootfs.tar.gz into a cpio file
# We are using cpio rootfs so we can change the files before booting
temp_dir=/tmp/lime_rootfs
rm -rf $temp_dir
mkdir -p $temp_dir
tar xf "${_arg_rootfs}" -C $temp_dir

# if a libremesh workdir is specified then we copy the files from the workdir
# into the rootfs
if [ "$_arg_libremesh_workdir" ]; then
    # Copying the new lime overlay here
    for package in "${_arg_libremesh_workdir}"/packages/*/files/*; do
        cp -r "${package}" $temp_dir
    done
fi

# build the cdpio. Don't know how to do it without changing the directory
cd /tmp/lime_rootfs
find . -depth | cpio --quiet -o -H newc  > /tmp/lime_rootfs.cpio
cd - > /dev/null

MONITOR_PORT=$_arg_monitor_port

SERIAL=''
if [ "$_arg_serial" == "on" ]; then
    SERIAL="-serial mon:stdio"
fi

qemu_args=( \
    -m 128
    -smp 1,sockets=1,cores=1,threads=1
    -no-user-config
    -enable-kvm
    -nographic
    -nodefaults
    -no-reboot
    -kernel "${_arg_ramfs}"
    -initrd /tmp/lime_rootfs.cpio
    ${SERIAL}
    -monitor "telnet::${MONITOR_PORT},server,nowait"
    # Enable rng based on /dev/urandom to speed up rng initialization in the guest
    -object rng-random,filename=/dev/urandom,id=rng0
    -device virtio-rng-pci,rng=rng0
    # Enable Telnet to the main serial
    -serial telnet:localhost:45455,server,nowait
    # LAN interface
    -netdev tap,id=hostnet0,ifname=lime_tap0,script=no,downscript=no
    -device e1000,netdev=hostnet0,id=net0,mac=52:00:00:ab:cd:00,bus=pci.0,addr=0x3
    # WAN interface
    -netdev tap,id=hostnet1,ifname=lime_tap1,script=no,downscript=no
    -device e1000,netdev=hostnet1,id=net1,mac=52:00:00:ab:cd:01,bus=pci.0,addr=0x4
)

exec qemu-system-x86_64 "${qemu_args[@]}"

# cleanup
ip tuntap del name lime_tap0 mode tap

if [ "$_arg_enable-wan" == "on" ]; then

    ip tuntap del name lime_tap1 mode tap

    # End dnsmasaq
    kill -TERM `cat /var/run/dnsmasq.pid`

fi
# ] <-- needed because of Argbash
