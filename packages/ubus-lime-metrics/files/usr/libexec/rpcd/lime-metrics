#!/usr/bin/env lua
--[[
  Copyright (C) 2013-2017 LibreMesh.org
  This is free software, licensed under the GNU AFFERO GENERAL PUBLIC LICENSE Version 3

  Copyright 2017 Marcos Gutierrez <gmarcos@altermindi.net>
  Copyright 2017 Nicolas Echaniz <nicoechaniz@altermundi.net>
]]--

local ubus = require "ubus"
local json = require 'luci.jsonc'
local utils = require("lime.utils")
local metrics_utils = require("lime.metrics.metrics_utils")


local conn = ubus.connect()
if not conn then
    error("Failed to connect to ubus")
end

local function _get_metrics(target)
    local result = {}
    local node = utils.shell_quote(target)
    local loss = nil
    local shell_output = ""

    if utils.is_installed("lime-proto-bmx6") then
        loss = metrics_utils.get_loss(node..".mesh", 6)
        shell_output = utils.unsafe_shell("netperf -6 -l 10 -H "..node..".mesh| tail -n1| awk '{ print $5 }'")
    elseif utils.is_installed("lime-proto-babeld") then
        loss = metrics_utils.get_loss(node, 4)
        shell_output = utils.unsafe_shell("netperf -l 10 -H "..node.."| tail -n1| awk '{ print $5 }'")
    else
        return {status="error", error={msg="No protocol known to get metrics.", code="1"}}
    end
    local bw = 0
    if shell_output ~= "" then
        bw = shell_output:match("[%d.]+")
    end
    return {status="ok", bandwidth=bw, loss=loss}
end

local function get_metrics(msg)
    local result = _get_metrics(msg.target)
    utils.printJson(result)
end

local function _get_gateway()
    local result = {}
    local gw = nil

    local path = metrics_utils.get_last_internet_path()
    if utils.tableLength(path) > 0 then
        return { status="ok", gateway=path[utils.tableLength(path)] }
    end

    return {status="error", error={msg="Not found. No gateway available.", code="1"}}
end

local function get_gateway(msg)
    utils.printJson(_get_gateway())
end

local function get_last_internet_path(msg)
    local path = metrics_utils.get_last_internet_path()
    if path ~= nil then
        utils.printJson({status="ok", path=path})
    else
        utils.printJson({status="error", error={msg="Not found. No known Internet path.", code="1"}})
    end
end

local function _get_path(target)
    local node = target
    local result = {}
    local path = {}
    local path_str = shell("traceroute6 -q 1 "..node..".mesh | grep ms | awk '{ print $2 }' | cut -d'.' -f1")
    for l in path_str:gmatch("[^\n]*") do
        if l ~= "" then
            table.insert(path, l)
        end
    end
    result.path = path
    result.status = "ok"
    return result
end
local function get_path(msg)
    --printJson(_get_path(msg.target))
    get_last_internet_path()
end

local function get_internet_status(msg)
    local result = {}

    result.IPv4 = { working = metrics_utils.get_loss("4.2.2.2") ~= "100" }

    result.IPv6 = { working = metrics_utils.get_loss("2600::", 6) ~= "100"}

    result.DNS = { working = metrics_utils.is_nslookup_working() }

    result.status = "ok"
    utils.printJson(result)
end

local function get_station_traffic(msg)
    local iface = utils.shell_quote(msg.iface)
    local mac = utils.shell_quote(msg.station_mac)
    local result = {}
    local cmd = "iw " .. iface .. " station get " .. mac .. " | grep bytes | awk '{ print $3}'"
    local traffic = utils.unsafe_shell(cmd)
    local words = {}
    for w in traffic:gmatch("[^\n]+") do
        table.insert(words, w)
    end
    local rx = words[1]
    local tx = words[2]
    result.station = mac
    if rx ~= nil then
        result.rx_bytes = tonumber(rx, 10)
        result.tx_bytes = tonumber(tx, 10)
        result.status = "ok"
    else
        result = {status="error", error={msg="Interface or station not found.", code="1"}}
    end
    utils.printJson(result)
end

local methods = {
    get_metrics = { target = 'value' },
    get_gateway = { no_params = 0 },
    get_path = { target = 'value' },
    get_last_internet_path = { no_params = 0 },
    get_internet_status = { no_params = 0 },
    get_station_traffic = { iface = 'value', station_mac = 'value' }
}

if arg[1] == 'list' then
    utils.printJson(methods)
end

if arg[1] == 'call' then
    local msg = utils.rpcd_readline()
    msg = json.parse(msg)
    if       arg[2] == 'get_metrics'            then get_metrics(msg)
    elseif   arg[2] == 'get_gateway'            then get_gateway(msg)
    elseif   arg[2] == 'get_path'               then get_path(msg)
    elseif   arg[2] == 'get_last_internet_path' then get_last_internet_path(msg)
    elseif   arg[2] == 'get_internet_status'    then get_internet_status(msg)
    elseif   arg[2] == 'get_station_traffic'    then get_station_traffic(msg)
    else                                        utils.printJson({ error = "Method not found" })
    end
end
